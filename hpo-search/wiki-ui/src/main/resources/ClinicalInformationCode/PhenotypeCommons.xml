<?xml version="1.0" encoding="UTF-8"?>
<xwikidoc>
<web>ClinicalInformationCode</web>
<name>PhenotypeCommons</name>
<language></language>
<defaultLanguage>en</defaultLanguage>
<translation>0</translation>
<parent></parent>
<creator>xwiki:XWiki.Admin</creator>
<author>xwiki:XWiki.Admin</author>
<customClass></customClass>
<contentAuthor>xwiki:XWiki.Admin</contentAuthor>
<creationDate>1322763262000</creationDate>
<date>1324424737000</date>
<contentUpdateDate>1324424737000</contentUpdateDate>
<version>1.1</version>
<title></title>
<template></template>
<defaultTemplate></defaultTemplate>
<validationScript></validationScript>
<comment></comment>
<minorEdit>false</minorEdit>
<syntaxId>xwiki/2.0</syntaxId>
<hidden>false</hidden>
<content>{{groovy}}
public class PhenotypeDisplayTools {

  public static final String __OTHER_FIELD_MARKER = '_other';
  public static final String __RESTRICTION_FIELD_MARKER = '_category';
  public static final String __CUSTOM_MAPPING_FIELD_MARKER = '_mapping';
  public static final String __IMAGE_FIELD_MARKER = '_image';

  public static final String __CUSTOM_MAPPING_CLASS = 'ClinicalInformationCode.CategoryMappingClass';
  public static final String __CUSTOM_MAPPING_CATEGORY_ID_FIELD = 'category_id';
  public static final String __CUSTOM_MAPPING_VALUES_FIELD = 'values';
  public static final String __CUSTOM_MAPPING_IMAGES_FIELD = 'images';

  public static final String __EMPTY_SECTION_MESSAGE = 'None specified';

  public String OTHER_FIELD_MARKER() {return __OTHER_FIELD_MARKER;}
  public String RESTRICTION_FIELD_MARKER() {return __RESTRICTION_FIELD_MARKER;}
  public String CUSTOM_MAPPING_FIELD_MARKER() {return __CUSTOM_MAPPING_FIELD_MARKER;}
  public String IMAGE_FIELD_MARKER() {return __IMAGE_FIELD_MARKER;}


  private Object ontologyService;
  private String name = '';
  private String propertyName = '';
  private String mode = 'view';
  private Object document;
  private Set&lt;String&gt; selectedValues = new HashSet&lt;String&gt;();
  private Map&lt;String, String&gt; messages = new LinkedHashMap&lt;String, String&gt;();

  public PhenotypeDisplayTools(Object ontologyService)
  {
    this.ontologyService = ontologyService;
  }

  public void use(String prefix, String name)
  {
    this.name = prefix + name;
    this.propertyName = name;
  }
  public void setMode(String mode)
  {
    this.mode = mode;
  }
  public void setDocument(Object document)
  {
    this.document = document;
  }
  public void setSelectedValues(Object values)
  {
    if (values instanceof ArrayList) {
      this.selectedValues.addAll(values);
    }
  }
  public void setMessageMap(Map&lt;String, String&gt; messages)
  {
    if (messages != null) {
      this.messages.putAll(messages);
    }
  }

  public void reset()
  {
    this.name = '';
    this.mode = '';
    this.document = null;
    this.selectedValues.clear();
    this.messages.clear();
  }

  private String getLabelFromOntology(String id)
  {
    def phObj = ontologyService.get(id);
    if (phObj) {
      return phObj.name;
    }
    return id;
  }

  private String getDisplayedImageProperty(String caption, Object dataObj)
  {
    String result = '';
    if (caption) {
      result = '&lt;span class="caption"&gt;' + caption + "&lt;/span&gt;\n";
    }
    def objDisplay = dataObj.display(__CUSTOM_MAPPING_IMAGES_FIELD, this.mode);
    if (objDisplay.trim() != '') {
      result += objDisplay + "\n";
      return '&lt;div class="image-gallery' + (this.mode == 'edit' ? ' emphasized-box' : '') +'"&gt;' + result + '&lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt;';
    }
    return '';
  }

  private boolean isOntologyId(String id)
  {
    return id.matches("[A-Z]+:[0-9]{7}");
  }
  private boolean isOntologyOther(String id)
  {
    return id.equals(__OTHER_FIELD_MARKER);
  }
  private boolean isNonOntologyCheckBox(String id)
  {
    return !isOntologyOther(id) &amp;&amp; id.startsWith("_c_");
  }
  private boolean isNonOntologyInput(String id)
  {
    return !isOntologyOther(id) &amp;&amp; id.startsWith("_i_");
  }
  private boolean isFreeText(String id)
  {
    return !isOntologyOther(id) &amp;&amp; id.startsWith("_t_");
  }
  private boolean isImageField(String id)
  {
    return id.equals(__IMAGE_FIELD_MARKER);
  }
  private boolean isSubsection(String id)
  {
    return !isOntologyId(id) &amp;&amp; !id.startsWith("_");
  }
  private String wrapDetailsRequestMessage(String message)
  {
     return hintMessage("(Please list specific " + message + " in the \"Other\" box)");
  }
  private String hintMessage(String message)
  {
     return "&lt;div class='hint'&gt;" + message + "&lt;/div&gt;";
  }

  private boolean enableDropdown(String id)
  {
    return isOntologyId(id) &amp;&amp; (ontologyService.search(['is_a' : id], 1, 0).size() &gt; 0);
  }

  public String handleSection(LinkedHashMap&lt;String, Object&gt; sectionData)
  {
    
    String result = "";
    boolean hasOtherInput = false, hasImages = false;
    String restriction, mapping, imagesLabel;

    if (sectionData.containsKey(__OTHER_FIELD_MARKER)) {
      hasOtherInput = true;
      sectionData.remove(__OTHER_FIELD_MARKER);
    }
    if (sectionData.containsKey(__IMAGE_FIELD_MARKER)) {
      hasImages = true;
      imagesLabel = sectionData.remove(__IMAGE_FIELD_MARKER);
    }
    restriction = (String)sectionData.remove(__RESTRICTION_FIELD_MARKER);
    mapping = (String)sectionData.remove(__CUSTOM_MAPPING_FIELD_MARKER);
    def mappingObj = this.document.getObject(__CUSTOM_MAPPING_CLASS, __CUSTOM_MAPPING_CATEGORY_ID_FIELD, mapping);

    String customValueDisplay = '';
    String customValueDisplayField = '';
    if (mappingObj) {
      customValueDisplay = '';
      for (String val : mappingObj.getProperty(__CUSTOM_MAPPING_VALUES_FIELD).value) {
        customValueDisplay += generateCheckBox(val, getLabelFromOntology(val));
      }
      customValueDisplay = '&lt;div class="custom-display-data"&gt;' + customValueDisplay + '&lt;/div&gt;';

      String fieldName = __CUSTOM_MAPPING_CLASS + '_' + mappingObj.number + '_' + __CUSTOM_MAPPING_VALUES_FIELD;
      customValueDisplayField = "&lt;input class='mapping' type='hidden' name='" + fieldName + "' value='" + mappingObj.display(__CUSTOM_MAPPING_VALUES_FIELD, 'view') + "' /&gt;";
    }

    Object[] fieldIds = sectionData.keySet().toArray();
    for (int i = 0; i &lt; fieldIds.length; ++i) {
      result += handleField((String)fieldIds[i], sectionData);
    }

    if (hasOtherInput) {
      if (result) {
        result  = "&lt;div class='phenotypes-main half-width'&gt;" + result + "&lt;/div&gt;";
        result += "&lt;div class='phenotypes-other half-width'&gt;";
      } else {
        result  = "&lt;div class='phenotypes-main'&gt;";
      }
      result += customValueDisplay;

      result += generateInput( __OTHER_FIELD_MARKER, true);
      if (restriction != null) {
	result += "&lt;input type='hidden' name='" + __RESTRICTION_FIELD_MARKER + "' value='" + restriction + "' /&gt;";
      }

      result += customValueDisplayField;

      result += "&lt;/div&gt;";
      result += "&lt;div class='clear'&gt;&lt;/div&gt;";

    } else {
      
      result  = "&lt;div class='phenotypes-main'&gt;" + result + customValueDisplay + customValueDisplayField + "&lt;/div&gt;";
    }

    if (hasImages &amp;&amp; mappingObj) {
      result += getDisplayedImageProperty(imagesLabel, mappingObj);
    }
    return result;
  }
  private String handleField(String id, LinkedHashMap&lt;String, Object&gt; data)
  {
    Object label = (data.get(id) == null ? getLabelFromOntology(id) : data.get(id));
    if (isOntologyId(id)) {
      return generateCheckBox(id, (String)label);
    } else if (isOntologyOther(id)) {
      return generateInput((String)label, true);
    } else if (isNonOntologyCheckBox(id)) {
      return generateCheckBox(id.substring(3), (String)label);
    } else if (isNonOntologyInput(id)) {
      return generateInput((String)label, false);
    } else if (isSubsection(id)) {
      return "&lt;label class='section'&gt;" + id + "&lt;/label&gt;&lt;div class='subsection'&gt;" + handleSection((LinkedHashMap&lt;String, Object&gt;)data.get(id)) + "&lt;/div&gt;";
    } else if (isFreeText(id)) {
      return generateFreeText((String)label);
    }
    return "";
  }

  private String generateCheckBox(String value, String label)
  {
    if (this.mode != 'edit') {
      return "&lt;div class='value-checked'&gt;" + label + "&lt;/div&gt;";
    }
    String cssClass = "term-label" + (enableDropdown(value) ? " dropdown-root" : "");
    String id = name + (value.startsWith("_") ? "" : "_") + value;
    String message = this.messages.get(value);
    message = (message == null) ? "" : this.wrapDetailsRequestMessage(message);
    String checked = this.selectedValues.contains(value) ? " checked='checked' " : "";
    return "&lt;label class='" + cssClass + "' for='" + id + "'&gt;&lt;input type='checkbox' " + checked + " name='" + name + "' id='" + id + "' value='" + value + "'/&gt;" + label + "&lt;/label&gt;&lt;br/&gt;" + message;
  }
  private String generateInput(String label, boolean suggested)
  {
    String result = "";
    String id = name + "_" + Math.random();
    String displayedLabel = (suggested ? "Other" : label);
    if (displayedLabel.matches("^\\(.*\\)\$")) {
      displayedLabel = "&lt;span class='hint'&gt;" + displayedLabel + "&lt;/span&gt;";
    } else {
      displayedLabel += ":";
    }
    result = "&lt;label for='" + id + "'" + (suggested ? " class='label-other label-other-" + name + "'" : "") + "&gt;" + displayedLabel + "&lt;/label&gt;";
    if (suggested) {
      result +="&lt;p class='hint'&gt;(enter a free text and choose among suggested ontology terms)&lt;/p&gt;";
    }
    result +="&lt;input type='text' name='" + name + "'" +(suggested ? "' class='suggested multi suggest-hpo generateCheckboxes'" : "") + " value='' size='16' id='" + id + "'/&gt;";
    return result;
  }
  private String generateFreeText(String label)
  {
    String result = "";
    String id = name + "_" + Math.random();
    result = "&lt;label for='" + id + "'" + "&gt;" + label + "&lt;/label&gt;";
    result +="&lt;textarea name='" + name + "' rows='8' cols='40' id='" + id + "'&gt;&lt;/textarea&gt;";
    return result;
  }

  private boolean hasSections(LinkedHashMap&lt;String, Object&gt; data)
  {
     Object[] sections = data.values().toArray();
     return (sections.length &gt; 0 &amp;&amp; sections[0] instanceof LinkedHashMap);
  }

  private void cleanSections(LinkedHashMap&lt;String, LinkedHashMap&lt;String, Object&gt;&gt; data)
  {
    Object[] sectionNames = data.keySet().toArray();
    ArrayList&lt;String&gt; sectionsToRemove = new ArrayList&lt;String&gt;();
    for (int i = 0; i &lt; sectionNames.length; ++i) {
      LinkedHashMap&lt;String, Object&gt; section = data.get(sectionNames[i]);
      cleanSection(section);
      if (section.isEmpty()) {
        sectionsToRemove.add(sectionNames[i]);
      }
    }
    for (int i = 0; i &lt; sectionsToRemove.size(); ++i) {
      data.remove(sectionsToRemove[i]);
    }
  }
  private void cleanSection(LinkedHashMap&lt;String, Object&gt; section)
  {
    Object[] fieldIds = section.keySet().toArray();

    def fieldsToAdd = getSectionCustomValues(section);

    ArrayList&lt;String&gt; fieldsToRemove = new ArrayList&lt;String&gt;();
    for (int i = 0; i &lt; fieldIds.length; ++i) {
      String id = fieldIds[i];
      if (isSubsection(id)) {
        LinkedHashMap&lt;String, Object&gt; subsection = section.get(fieldIds[i]);
        cleanSection(subsection);
        if (subsection.isEmpty()) {
          fieldsToRemove.add(fieldIds[i]);
        }
      } else {
         if (!this.selectedValues.contains(id)) {
           fieldsToRemove.add(fieldIds[i]);
         }
      }
    }
    for (int i = 0; i &lt; fieldsToRemove.size(); ++i) {
      section.remove(fieldsToRemove[i]);
    }

    addSectionCustomValues(section, fieldsToAdd);
  }

  private Map&lt;String, String&gt; addSectionCustomValues(LinkedHashMap&lt;String, Object&gt; section, Map&lt;String, String&gt; customValues)
  {
    Object[] fieldIds = customValues.keySet().toArray();
    for (int i = 0; i &lt; fieldIds.length; ++i) {
      //section.put(fieldIds[i], (Object)fieldsToAdd.get(fieldIds[i]));
      //just a trick to make it work without class cast errors...
      section.put(customValues.get(fieldIds[i]), new LinkedHashMap&lt;String, Object&gt;());
    }
  }

  private Map&lt;String, String&gt; getSectionCustomValues(LinkedHashMap&lt;String, Object&gt; section)
  {
     String mapping = (String)section.remove(__CUSTOM_MAPPING_FIELD_MARKER);
     if (mapping) {
       def mappingObj = this.document.getObject(__CUSTOM_MAPPING_CLASS, __CUSTOM_MAPPING_CATEGORY_ID_FIELD, mapping);
       if (mappingObj) {
         LinkedHashMap&lt;String, String&gt; result = getSectionCustomValues(section, mappingObj.getProperty(__CUSTOM_MAPPING_VALUES_FIELD).value);
         if (section.containsKey(__IMAGE_FIELD_MARKER)) {
           def displayedImages = getDisplayedImageProperty(section.remove(__IMAGE_FIELD_MARKER), mappingObj);
           if (displayedImages != '') {
             result.put(__IMAGE_FIELD_MARKER, displayedImages);
           }
         }
         return result;
       }
     }
     return new LinkedHashMap&lt;String, String&gt;();
  }

  private Map&lt;String, String&gt; getSectionCustomValues(LinkedHashMap&lt;String, Object&gt; section, Collection&lt;String&gt; otherValues)
  {
     LinkedHashMap&lt;String, String&gt; result = new LinkedHashMap&lt;String, String&gt;();
     for (String val : otherValues) {
       if (!section.containsKey(val.substring(3))) {
          def label;
          def phObj = ontologyService.get(val)
          if (phObj) {
             label = phObj.name;
          } else {
             label = val;
          }
          result.put(val, label);
       }
     }
     return result;
  }

  public String display(LinkedHashMap&lt;String, Object&gt; data)
  {
     if (hasSections(data)) {
        if (this.mode != 'edit') {
          cleanSections(data);
          if (data.isEmpty()) {
            return "{{html wiki=true clean=false}}\n" + hintMessage(__EMPTY_SECTION_MESSAGE) + "\n{{/html}}\n";
          } 
        }
        Object[] sectionNames = data.keySet().toArray();
        String result = '';
        for (int i = 0; i &lt; sectionNames.length; ++i) {
          result += '(% class="' + propertyName + '-group" %)(((\n';
          result += '===' + sectionNames[i] + '===\n';
          result += '{{html wiki=true clean=false}}\n' + handleSection(data.get(sectionNames[i])) + '{{/html}}';
          result += ')))\n';
        }
        return result;
     } else {
        if (this.mode != 'edit') {
          def fieldsToAdd = getSectionCustomValues(data);
          cleanSection(data);
          addSectionCustomValues(data, fieldsToAdd);
          if (data.isEmpty()) {
            return "{{html wiki=true clean=false}}\n" + hintMessage(__EMPTY_SECTION_MESSAGE) + "\n{{/html}}\n";
          }
        }
        return "{{html wiki=true clean=false}}\n" + handleSection(data) + "\n{{/html}}\n";
     }
  }
}

def vcontext = xcontext.get('vcontext');
vcontext.put('phenotypeDisplayTools', new PhenotypeDisplayTools(vcontext.services.solr));
{{/groovy}}</content></xwikidoc>
